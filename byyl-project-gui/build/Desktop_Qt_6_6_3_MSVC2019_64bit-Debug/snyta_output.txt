void -> void
ID -> main
Lparen -> (
void -> void
Rparen -> )
Lbrace -> {
int -> int
ID -> a
branch -> ;
int -> int
ID -> iternet
branch -> ;
float -> float
ID -> b
Lbracket -> [
NUM -> 10
Rbracket -> ]
branch -> ;
ID -> a
assignop -> =
NUM -> 5
branch -> ;
ID -> b
Lbracket -> [
NUM -> 2
Rbracket -> ]
assignop -> =
NUM -> 3.14
branch -> ;
if -> if
Lparen -> (
ID -> a
gt -> >
NUM -> 0
Rparen -> )
Lbrace -> {
int -> int
ID -> i
Lbracket -> [
NUM -> 90
Rbracket -> ]
branch -> ;
ID -> a
assignop -> =
ID -> a
mul -> *
NUM -> 3
branch -> ;
ID -> b
Lbracket -> [
NUM -> 1
Rbracket -> ]
assignop -> =
ID -> b
Lbracket -> [
NUM -> 2
Rbracket -> ]
div -> /
NUM -> 8
branch -> ;
ID -> i
Lbracket -> [
NUM -> 10
Rbracket -> ]
assignop -> =
NUM -> 10
branch -> ;
Rbrace -> }
else -> else
Lbrace -> {
while -> while
Lparen -> (
ID -> a
lt -> <
NUM -> 10
Rparen -> )
Lbrace -> {
double -> double
ID -> d
Lbracket -> [
NUM -> 10
Rbracket -> ]
branch -> ;
int -> int
ID -> m
branch -> ;
ID -> a
assignop -> =
ID -> a
add -> +
NUM -> 1
branch -> ;
ID -> m
assignop -> =
NUM -> 0
branch -> ;
do -> do
Lbrace -> {
ID -> d
Lbracket -> [
ID -> m
Rbracket -> ]
assignop -> =
ID -> m
branch -> ;
ID -> m
assignop -> =
ID -> m
add -> +
NUM -> 1
branch -> ;
Rbrace -> }
while -> while
Lparen -> (
ID -> m
le -> <=
NUM -> 9
Rparen -> )
branch -> ;
Rbrace -> }
branch -> ;
Rbrace -> }
branch -> ;
do -> do
Lbrace -> {
int -> int
ID -> c
branch -> ;
ID -> c
assignop -> =
NUM -> 3
branch -> ;
ID -> b
Lbracket -> [
NUM -> 2
Rbracket -> ]
assignop -> =
ID -> b
Lbracket -> [
NUM -> 2
Rbracket -> ]
add -> +
NUM -> 4
branch -> ;
Rbrace -> }
while -> while
Lparen -> (
ID -> b
Lbracket -> [
NUM -> 2
Rbracket -> ]
lt -> <
NUM -> 10
Rparen -> )
branch -> ;
return -> return
branch -> ;
Rbrace -> }
